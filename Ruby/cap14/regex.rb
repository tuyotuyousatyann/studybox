# if文=~を使うとマッチしたかどうかを判別できる
if '123-4567' =~ /\d{3}-\d{4}/
  puts 'マッチしました'
else
  puts 'マッチしませんでした'
end
# => マッチしました

# if 文のブロック内では 'マッチしました' という文字列が puts されるため、それが出力される。その後、Rubyの if 文やメソッドは最後に評価された式の値を返すため、puts 'マッチしました' の返り値（nil、なぜなら puts は常に nil を返す）が if 文全体の返り値となる。したがって、ターミナルには 'マッチしました' と表示された後に、nil が返ってくる。

# 左辺に正規表現を置いても結果は同じ

/\d{3}-\d{4}/ =~ '123-4567' # => 0
/\d{3}-\d{4}/ =~ 'hello' # => nil

# !~を使うとマッチしなかった場合にtrueを返す

'hello' !~ /\d{3}-\d{4}/ # => true

# マッチしたらfalseを返す

'123-4567' !~ /\d{3}-\d{4}/ # => false

# キャプチャを使って、正規表現にマッチした部分を取得する。matchメソッドを使う。

text = '私の誕生日は1977年7月17日です。'
m = /(\d+)年(\d+)月(\d+)日/.match(text)
m[1] # => "1977"
m[2] # => "7"
m[3] # => "17"

# 文字列が正規表現にマッチすると、MatchDataオブジェクトが返る
# マッチしなかったらnilが返る

# <MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">

text = '私の誕生日は1977年7月17日です。'
# 真偽値の判定とローカル変数への代入を同時にやってしまう

if m = /(\d+)年(\d+)月(\d+)日/.match(text)
  # マッチした場合の処理
else
  # マッチしなかった場合の処理
end

# MatchDataを使うと、[]を使って正規表現の処理結果を配列と同じような方法で取得できる

text = '私の誕生日は1977年7月17日です。'
m = /(\d+)年(\d+)月(\d+)日/.match(text)
# マッチした部分全体を取得する
m[0] # => "1977年7月17日"
m[1] # => "1977"
# キャプチャの2番目から2個取得する
m[2, 2] # => ["7", "17"]
# 最後のキャプチャを取得する
m[-1] # => "17"
# Rangeを使って取得する
m[1..3] # => ["1997", "7", "17"]

# matchメソッドはStirngクラスとRegexpクラスの両方に定義されている
# 文字列と正規表現を入れ替えても同じ結果になる

text = '私の誕生日は1977年7月17日です。'
m = text.match(/(\d+)年(\d+)月(\d+)日/)
# => #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">

# 連番じゃなくて、名前でキャプチャの結果を取得する

text = '私の誕生日は1977年7月17日です'
m = (?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
# シンボルで名前を指定してキャプチャの結果を取得する
m[:year] # => "1977"
m[:month] # => "7"
m[:day] # => "17"

# 文字列で指定することもできる
m['year'] # => "1977"

# 連番で指定することもできる
m[2] # => "7"

# キャプチャの名前がそのままローカル変数に割り当てられる
text = '私の誕生日は1977年7月17日です。'
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ text
  puts "#{year}/#{month}/#{day}"
end

# => 1977/7/17

# 逆にしたら使えない
# 正規表現が右辺に来ると変数が作成されない
text = '私の誕生日は1977年7月17日です。'
if text =~ /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/
  puts "#{year}/#{month}/#{day}"
end

# undefined local variable or method `year' for main:Object (NameError)

# 正規表現オブジェクトを変数に入れのはだめ

text = '私の誕生日は1977年7月17日です。'
regexp = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/
if regexp =~ text
  puts "#{year}/#{month}/#{day}"
end

# undefined local variable or method `year' for main:Object (NameError)

# 組み込み変数でマッチの結果を取得することができるが、$~は記号の意味を覚えるのが大変になる。なので、MatchDataオブジェクトを使うほうがいい

text = '私の誕生日は1977年7月17日です。'
text =~ /(\d+)年(\d+)月(\d+)日/
# MatchDataオブジェクトを取得する
$~ # => #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">
# マッチした部分全体を取得する
$& # => "1977年7月17日"

# 1番目から3番目のキャプチャを取得する
$1 #=> "1977"
$2 #=> "7"
$3 #=> "17"

# 最後のキャプチャを取得する
$+ #=> "17"

# 正規表現と組み合わせると便利なStringクラスのメソッド

# scanメソッドは引数で渡した正規表現にマッチする部分を配列に入れて返す

'123 456 789'.scan(/\d+/) # => ["123", "456", "789"]

# 正規表現に()があるとキャプチャされた部分が配列になって返ってくる

'1977年7月17日 2021年12月31日'.scan(/(\d+)年(\d+)月(\d+)日/)
# => [["1977, "7", "17"], ["2021", "12", "31"]]

'1977年7月17日 2021年12月31日'.scan(/\d+年\d+月\d+日/)
# => ["1977年7月17日", "2021年12月31日"]

# []に正規表現を渡すと、文字列から正規表現にマッチした部分を抜き出す

text = '郵便番号は123-4567です'
text[/\d{3}-\d{4}/] 
# => "123-4567"

# マッチする部分がたくさんある時は、最初にマッチした文字列が返る

text = '123-4567 456-7890'
text[/\d{3}-\d{4}/]
# => "123-4567"

# 第2引数を渡すと、その番号のキャプチャを取得できる

text = '私の誕生日は1977年7月17日です。'
text[/(\d+)年(\d+)月(\d+)日/]
# => "1977年7月17日"

text[/(\d+)年(\d+)月(\d+)日/, 3]
# => "17"

# 名前付きチャプチャであれば名前で指定することもできる

text = '誕生日は1977年7月17日です。'
text[/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/, :day]
# => "17"

# 文字列でキャプチャの名前を指定することもできる

text[/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/, 'day']
# => "17"

# sliceメソッドを使っても同じ結果になる
text = '郵便番号は123-4567です'
text.slice(/\d{3}-\d{4}/)
# => "123-4567"

text = '私の誕生日は1977年7月17日です。'
text.slice(/(\d+)年(\d+)月(\d+)日/, 3)
# => "17"

# slice!メソッドを使うとマッチした部分が文字列から破壊的に取り除かれる

text = '郵便番号は123-4567です'
text.slice!(/\d{3}-\d{4}/)
# => "123-4567"
text # => "郵便番号はです"

# splitメソッドは引数で渡した正規表現で文字列を分割し、配列として返す
# 文字列で区切り文字を指定する
text = '123,456-789'
text.split(',')
# => ["123", "456-789"]

# 正規表現を使ってカンマまたはハイフンを区切り文字に指定する
text.split(/,|-/)
# => ["123", "456", "789"]

# gsubメソッドを使うと、第一引数の正規表現にマッチした文字列を第二引数の文字列で置き換える
# 第一引数に文字列を渡すと、完全一致する文字列を第二引数で置き換える
text = '123,456-789'
text.gsub(',', ':')
# => "123:456-789"

# 正規表現を渡すと、マッチした部分を第二引数で置き換える
text.gsub(/,|-/, ':')
# => "123:456:789"

# 第二引数にハッシュを渡して、変換のルールを指定する
# カンマはコロンに、ハイフンはスラッシュに置き換える
text = '123,456-789'
hash = { ',' => ':', '-' => '/' }
text.gsub(/,|-/, hash)
# => "123:456/789"

# 第二引数を渡す代わりに、ブロックの戻り値で置き換える文字列を指定することもできる
text = '123,456-789'
text.gsub(/,|-/) { |matched| matched == ',' ? ':' : '/' }
# => "123:456/789"

# gsub!メソッドは文字列の内容を破壊的に置き換える
text = '123,456-789'
text.gsub!(/,|-/, ':' )
text # => "123:456:789"

# 公式リファレンス上では、第二引数を渡す方法より、ブロックを使う方法を推奨している

